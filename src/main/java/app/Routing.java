package app;

import com.codahale.metrics.health.jvm.ThreadDeadlockHealthCheck;
import com.codahale.metrics.jvm.FileDescriptorRatioGauge;
import com.codahale.metrics.jvm.GarbageCollectorMetricSet;
import com.codahale.metrics.jvm.MemoryUsageGaugeSet;
import com.codahale.metrics.jvm.ThreadStatesGaugeSet;
import com.fasterxml.jackson.databind.ObjectMapper;
import io.jooby.*;
import io.jooby.handler.HeadHandler;
import io.jooby.hikari.HikariModule;
import io.jooby.jackson.JacksonModule;
import io.jooby.jdbi.JdbiModule;
import io.jooby.metrics.MetricsModule;
import io.swagger.v3.oas.annotations.OpenAPIDefinition;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.enums.ParameterIn;
import io.swagger.v3.oas.annotations.info.Contact;
import io.swagger.v3.oas.annotations.info.Info;
import io.swagger.v3.oas.annotations.info.License;
import io.swagger.v3.oas.annotations.media.ArraySchema;
import io.swagger.v3.oas.annotations.media.Content;
import io.swagger.v3.oas.annotations.media.Schema;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.responses.ApiResponses;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.jdbi.v3.core.Jdbi;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.time.Duration;
import java.util.List;

@OpenAPIDefinition(
        info = @Info(
                title = "Title",
                description = "description",
                termsOfService = "Terms",
                contact = @Contact(
                        name = "Jooby",
                        url = "https://jooby.io",
                        email = "support@jooby.io"
                ),
                license = @License(
                        name = "Apache",
                        url = "https://jooby.io/LICENSE"
                ),
                version = "10"
        ),
        tags = @Tag(name = "mytag")
)
public class Routing extends Jooby {

    private static final Logger log = LoggerFactory.getLogger(Routing.class);

    public Routing() {
        install(new JacksonModule(new ObjectMapper()));
        install(new MetricsModule()
                .threadDump()
                .ping()
                .healthCheck("deadlock", new ThreadDeadlockHealthCheck())
                .metric("memory", new MemoryUsageGaugeSet())
                .metric("threads", new ThreadStatesGaugeSet())
                .metric("gc", new GarbageCollectorMetricSet())
                .metric("fs", new FileDescriptorRatioGauge()));
        install(new GracefulShutdown(Duration.ofMinutes(1)));
        install(new HikariModule());
        install(new JdbiModule());
        install(new OpenAPIModule());

        use(new HeadHandler());
        use(next -> ctx -> logTimeTakenFilter(next, ctx));

        Jdbi jdbi = require(Jdbi.class);
        //initialize the database
        jdbi.withHandle(handle -> {
            handle.execute("CREATE TABLE IF NOT EXISTS users (id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY , name VARCHAR)");

            // Inline positional parameters
            handle.execute("INSERT INTO users( name) VALUES ( ?)",  "Alice");

            // Positional parameters
            handle.createUpdate("INSERT INTO users( name) VALUES ( ?)")
                    .bind(0, "Bob")
                    .execute();

            // Named parameters
            handle.createUpdate("INSERT INTO users( name)  VALUES ( :name)")
                    .bind("name", "Clarice")
                    .execute();

            // Named parameters from explicit binds (records aren't treated as beans by default)
            handle.createUpdate("INSERT INTO users( name) VALUES ( :name)")
                    .bind("name", "David")
                    .execute();

            // Easy mapping to any type
            return null;
        });


        /*
         * User operations.
         * @tag User
         */
        get("/", this::getHandler);


        get("/users", this::getUsersHandler);

        /*
         * Find a user by id.
         * @param id Integer.
         * @return A User.
         * @throws UserNotFoundException When a User doesn't exist. <code>404</code>
         * @operationId userById
         */
        get("/users/{id}", this::getUserByIdHandler);
        post("/users", this::createUser);
        put("/users/{id}", this::updateUser);

        onStarted(() -> {
            log.info("--------------------------------------------------");
            log.info("Application '{}' is ready!", getName());
            log.info("Listening http on: http://localhost:{}", getServerOptions().getPort());
            log.info("Listening https on: http://localhost:{}", getServerOptions().getSecurePort());
            log.info("--------------------------------------------------");
        });

        onStop(() -> {
            log.info("--------------------------------------------------");
            log.info("Application '{}' is stopping...", getName());
        });
    }



    private static Object logTimeTakenFilter(Route.Handler next, Context ctx) throws Exception {
        long start = System.nanoTime();
        Object response = next.apply(ctx);
        long end = System.nanoTime();
        long took =end - start;
        log.info(" {} \"{} {}\" Status {} time took: {} nanoseconds", ctx.getRemoteAddress() , ctx.getMethod(), ctx.getRequestPath(), ctx.getResponseCode().value(),took);
        return response;
    }

    private String getHandler(Context ctx) {
        return "Welcome to Jooby!";
    }
    @Operation(
            summary = "Get All users",
            description = "Returns all the users stored"
    )
    @ApiResponse(
            description = "Returns all the fetched users ",
            content = {
                    @Content(
                            mediaType = "application/json",
                            array = @ArraySchema(schema = @Schema(implementation = User.class))
                    )
            }
    )
    @Tag(name = "Users", description = "Fetch all users operations")
    public List<User> getUsersHandler(Context ctx) {
        var jdbi = require(Jdbi.class);
        return jdbi.withHandle(handle -> handle.createQuery("SELECT * FROM users ORDER BY name")
                .registerRowMapper(User.class ,
                        (rs,ctx1) -> new User(rs.getInt("id"),rs.getString("name")))
                .mapTo(User.class)
                .list());
    }

    @Operation(
            summary = "Create User"
    )
    @ApiResponses({
    @ApiResponse(
            responseCode = "200",
            description = "Returns the new user details after creation",
            content = {
                    @Content(
                            mediaType = "application/json",
                            schema = @Schema(implementation = User.class)
                    )
            }
    )
    })
    @Tag(name = "Users", description = "Create a new User")
    public User createUser(Context ctx){
        var jdbi = require(Jdbi.class);
        return jdbi.withHandle(handle -> {
            User user = ctx.body(User.class);
            var update = handle.createUpdate("INSERT INTO users(name) VALUES (:name)")
                    .bind("name", user.name())
                    .executeAndReturnGeneratedKeys("id")
                    .mapTo(Long.class);
            long id = update.one();
            return new User(id, user.name());
        });
    }
    @Operation(
            summary = "Fetch the User based on the id",
            parameters = {
                    @Parameter(
                            name = "id",
                            in = ParameterIn.PATH,
                            required =true,
                            description ="User id from path"
                    )
            },
            description = "Fetch the user based on the Id "
    )
    @ApiResponse(
            description = "Returns the fetched user details",
            content = {
                    @Content(
                            mediaType = "application/json",
                            schema = @Schema(implementation = User.class)
                    )
            }
    )
    @Tag(name = "Users", description = "Fetch a User based on the id")
    public User getUserByIdHandler(Context ctx) {
        var jdbi = require(Jdbi.class);
        int id = ctx.path("id").intValue();
        return jdbi.withHandle(handle -> handle.createQuery("SELECT * FROM users where id = :id")
                .bind("id", id)
                .registerRowMapper(User.class ,
                        (rs,ctx1) -> new User(rs.getInt("id"),rs.getString("name")))
                .mapTo(User.class)
                .one());
    }

    @Operation(
            summary = "Update the User based on the id",
            parameters = {
                    @Parameter(
                            name = "id",
                            in = ParameterIn.PATH,
                            required =true,
                            description ="User id from path"
                    )
            },
            description = "Greets a user by name from the path"
    )
    @ApiResponse(
            description = "Returns the fetched and then updated user details",
            content = {
                    @Content(
                            mediaType = "application/json",
                            schema = @Schema(implementation = User.class)
                    )
            }
    )
    @Tag(name = "Users", description = "Update the User based on the id")
    public User updateUser(Context ctx){
        var jdbi = require(Jdbi.class);
        return jdbi.withHandle(handle -> {
            int id = ctx.path("id").intValue();
            User user = ctx.body(User.class);
            handle.createUpdate("Update users SET name = :name WHERE id = :id")
                    .bind("id", id)
                    .bind("name", user.name())
                    .execute();
            return user;
        });
    }
}
